## Const

### Const и переменные

#### Const перед звездочкой

Перед звездочкой, **const** действует на данные

```cpp
int a = 10;
const int * b = &a; // Через переменную b нельзя изменять данные
//int const * b = &a; тоже самое
b++; // Нормально
(*b)++; // Ошибка компиляции
```

#### Const после звездочки

После звездочки, **const** действует на переменную

```c++
int a = 10;
int * const b = &a; // Нельзя изменить переменную b, но можно изменить данные
b++; // Ошибка компиляции
(*b)++; // Нормально
```

#### Const до и после звездочки

После звездочки, **const** действует и на переменную и на данные

```c++
int a = 10;
const int * const b = &a; // Нельзя изменить переменную b и через переменную b нельзя изменять данные
b++; // Ошибка компиляции
(*b)++; // Ошибка компиляции
```

### Const и функция

Перед названием функции **const** относится к возвращаемому типу данных, а **const** после названия функции говорит о том, что функция константная и не может изменять члены-данные класса.

Несколько способов, при которых константная функция может изменять члены-данные класса:

1. Ключевое слово **mutable** перед переменной;
2. Функция **const_cast**, способная снимать константность. 

```c++
class A
{
  public:
  int value = 10;
  mutable value2 = 20;
  const int * foo(); // const перед названием функции
  int foo2() const; // const после названия функции - константная функция
}

const int * A::foo() // Модификатор const относится к возвращаемому типу данных
{
    value += 1; // Поля возможно изменять
    return &value;
}

int A::foo2() // Модификатор const относится к возможностям функции внутри класса
{
    value += 1; // ERROR: Поля нельзя изменять
    const_cast<int&>(value) += 22; // Нормально, т.к. снята константность
    value2 += 13; // Нормально, т.к. ключевое слово mutable
    return value;
}
```




## Перегрузка функций

### Выбор перегруженной функции
