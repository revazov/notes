## Const

### Const и переменные

#### Const перед звездочкой

Перед звездочкой, **const** действует на данные

```cpp
int a = 10;
const int * b = &a; // Через переменную b нельзя изменять данные
//int const * b = &a; тоже самое
b++; // Нормально
(*b)++; // Ошибка компиляции
```

#### Const после звездочки

После звездочки, **const** действует на переменную

```c++
int a = 10;
int * const b = &a; // Нельзя изменить переменную b, но можно изменить данные
b++; // Ошибка компиляции
(*b)++; // Нормально
```

#### Const до и после звездочки

После звездочки, **const** действует и на переменную и на данные

```c++
int a = 10;
const int * const b = &a; // Нельзя изменить переменную b и через переменную b нельзя изменять данные
b++; // Ошибка компиляции
(*b)++; // Ошибка компиляции
```

### Const и функция

Перед названием функции **const** относится к возвращаемому типу данных, а **const** после названия функции говорит о том, что функция константная и не может изменять члены-данные класса.

Несколько способов, при которых константная функция может изменять члены-данные класса:

1. Ключевое слово **mutable** перед переменной;
2. Функция **const_cast**, способная снимать константность. 

```c++
class A
{
  public:
  int value = 10;
  mutable value2 = 20;
  const int * foo(); // const перед названием функции
  int foo2() const; // const после названия функции - константная функция
};

const int * A::foo() // Модификатор const относится к возвращаемому типу данных
{
    value += 1; // Поля возможно изменять
    return &value;
}

int A::foo2() const // Модификатор const относится к возможностям функции внутри класса
{
    value += 1; // ERROR: Поля нельзя изменять
    const_cast<int&>(value) += 22; // Нормально, т.к. снята константность
    value2 += 13; // Нормально, т.к. ключевое слово mutable
    return value;
}
```




## Перегрузка функций

### Выбор перегруженной функции

Компилятор для выяснения, какую функцию выбирать совершает следующие действия:
 1. Отбирает все функции с заданным именем в текущей области видимости;
 2. Исключает из этого списка те, у которых не подходящее количество параметров (**внимание**, `void f(int x, int y = 0)` подходящий кандидат для вызона `f(25);`);
 3. Если нет подходящих функций, то компилятор сообщает об ошибке;
 4. Если подходит больше одной, то выбирается **лучшее соответствие**;
 5. Если не найдено **лучшее соответствие**, то компилятор сообщает об ошибке - вызов неоднозначной функции.

 ### Выбор лучшего соответствия

 При выведении лучшего соответствия у компилятора есть система приоритетов:
  1. Точное совпадение (т.е. аргумент `double` и параметр `double`);
  2. Приведение типов (*promotion*);
  3. Встроенные преобразования типов (*standart type conversion*);
  4. Конструктор или пользовательское преобразование типов.

#### Приведение типов

**Приведение интегральных типов:**

| From  | To | Условие |
| ------------- | ------------- | --- |
| signed char, signed short | int  | |
| unsigned char, unsigned short | int, unsigned | Если int может вместить, то int, иначе unsigned |
 